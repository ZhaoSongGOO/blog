# 构建系统组装：理论与实践

> 本文总阅读量 <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>次

> [原文链接](https://www.cambridge.org/core/journals/journal-of-functional-programming/article/build-systems-a-la-carte-theory-and-practice/097CE52C750E69BD16B78C318754C7A4)

## Abstract

构建系统让人惊艳但是又不怎么受欢迎。它每天被世界上数以万计的开发者所使用，但是很少作为研究学习的内容。
在这个论文中，我们通过将不同的构建系统放在一起比较，得出了一个系统的且可落地的研究框架，借助于这个框架，可以更好的开发与比较不同的构建系统。
通过剖析现有的构建系统，我们可以重新组合他们的基础部件，以实现一个具有新特性的构建系统。

## 1. Introduction
例如 Make，构建系统这种软件是庞大且复杂的，每天被全球数以万计的软件开发人员所使用。但是构建系统往往是软件生态中被遗忘的部分，往往是达成目标的手段，而不会获得更多的关注在其本身。在 Make 统治了数年之后，现在新的场景和需求已经驱动了大量的软件公司，例如微软 、FaceBook 、和 Google 去开发他们自己的构建系统，并在构建系统领域探索新的方案与设计。这些复杂的构建系统使用了一些精妙/微妙的算法，但是往往将其隐藏在底层，并不需要用户进一步了解。

在这个论文中，我们给出一个用于理解和比较构建系统的通用框架，某种程度上来说，这个框架屏蔽了具体的细节，从更高维度去解释构建系统，但是同时也是可实现的。下面具体指出了，我们做的主要工作：

- 构建系统在很多方面存在差异，例如：静态依赖与动态依赖 、本地与云端 、确定性与非确定性构建系统 、早期截断(early cutoff) 、自跟踪构建 、和不同的构建信息存储类型。在第二节，我们通过选择的四个构建系统来对这些关键特性进行说明。
- 在第三节，我们提出了一些简单但是新颖的抽象概念来概括构建系统，通过这些概念，我们可以更好的评估一个构建系统正确性。
- 在第四节和第五节，我们提出了两个被深深嵌入到构建系统的关键设计选择：任务按照什么顺序执行  、任务是否需要重新构建。上面提到的两个选择是正交关系，这也给了我们对构建系统设计空间提供了新的分类标准，这将在第六节进一步说明。
- 基于两个设计的关键选择，我们通过对实际的构建系统：Make 、SHAKE 、BAZEL、BUCK、NIX、EXCEL 等进行细致描述，进一步证明了我们的抽象概念的正确性。
- 还有，我们可以通过组合不同的设计选择来构建出我们需要的构建系统。例如，我们可以组合 SHAKE 和 BAZEL 的优点去实现一个具有动态依赖和云构建模式的构建系统。第七节将对这种组合方式进行规则描述。

## 2. Background
不管是独立开发者还是大型组织，构建系统都是用来自动化执行一些重复的任务。在本小节，我们通过四个例子来探索构建系统的设计空间：Make，EXCEL，Bazel，SHAKE。我们仔细的选择这四个例子去阐明不同构建系统在不同方面的差异。我们在后续的章节也会针对于更多的构建系统进行讨论。

### 2.1 古老的 MAKE：静态依赖与文件更改时间

MAKE 在四十多年前被开发来用于源码到库以及可执行程序的构建。它使用 makefiles 文件来进行描述任务，通常被描述成构建规则和构建依赖：

```makefile
util.o: util.h util.c
    gcc -c util.c

main.o: util.h main.c
    gcc -c main.c

main.exe: util.o main.o
    gcc util.o main.o -o main.exe
```

在上面的 makefile 中列举了三个任务：(1) 通过执行 `gcc -c` 命令来将 util.c 编译生成一个工具类的库。 (2) 编译主函数的源代码文件 main.c 生成 main.o。（3）将目标文件 main.o 和 util.o 连接生成可执行文件 main.exe。从这个 makefile 文件中我们可以得到关于这个任务依赖图的完整信息，如下图(a) 所示 。

<img src="compile/buildsystem/paper/01/resources/1.png" style="width:50%">

如果用户指定 main.exe 为输出执行 make 命令，因为 main.o 和 util.o 之间相互独立，MAKE 将会以任意的顺序来执行这两个任务(甚至是并行)，然后执行 main.exe 生成所需结果。

如果用户修改了 util.h 然后重新运行，因为所有的三个任务都传递性的依赖了 util.h，MAKE 将执行一次全量重新构建 (full rebuild)，就像图 (b) 中描述的。

如果用户修改了 main.c, 那将会只执行一次部分构建: util.o 没有必要被重新构建，因为它的输入没有被更改，如图 (c) 所示。

可以观察到图中的任务不存在循环依赖，那每个任务在每次构建中最多被运行一次。一般来说，循环依赖在构建系统中是被禁止的，但是也有一些特殊情况，这点我们将在 8.5 小节进行说明。

在一次重新构建过程中，执行的任务数量越少约好。更具体的来讲，我们提出下面这个属性来描述构建系统，这个属性至关重要，也是我们为什么需要构建系统的原因：

<b>最小性(Minimality)</b>:如果一个构建系统的任务在一次构建过程中最多构建一次并且只有在它的输入自从上次构建后发生变更才会进行构建那我们称这个构建系统是最小化的。
> - 一个任务只会再一次构建中构建一次。
> - 输入没有变化则不会发生构建。

最小性这一特性与构建系统的正确性有着紧密的联系，我们会在 3.6 小节进行更详细的解释。但是现在，我们会把最小性作为我们分析构建系统的一个指导原则。

为了实现最小性，MAKE 提出了两个主要的思路：(1) MAKE 使用文件修改时间来判断文件是否更改。 (2) 按照 makefile 中的描述构建了一个静态的任务依赖图，并按照拓扑排序的方式执行任务。对于更具体的描述，我们会在 4.1 小节和 6.2 小节进行解释。
> 拓扑排序（Topological Order）是指对有向无环图（DAG）中顶点的一种线性排序，使得如果图中存在一条从顶点 \(u\) 到顶点 \(v\) 的路径，那么在拓扑排序中，顶点 \(u\) 出现在顶点 \(v\) 的前面。拓扑排序常常用于描述一系列任务或依赖关系，确保任务按照依赖关系的顺序进行。在构建系统中，拓扑排序常用于确定构建任务的执行顺序，以确保依赖关系被正确处理。


### 2.2 EXCEL: 牺牲了最小性的动态依赖

EXCEL 是一个被伪装的构造系统，具体可以参考下面这个例子。

```txt
A1: 10      B1: A1 + A2
A2: 20
```

这里有两个输入单元 A1 和 A2，和一个用来计算两者合的任务，这个任务将会把计算的结果存储在 B1 中，如果输入有任何一个改动，将会进行重新计算。

不像 MAKE，EXCEL 无需在构建前知道所有的任务依赖关系，事实上，某些依赖关系会在计算过程中动态变化。例如：

```txt
A1: 10      B1: INDIRECT("A" & C1)     C1: 1
A2: 20
```

B1 单元格使用了 INDIRECT 函数，这个函数会解析里面的字符串获取到单元格名字，并进一步去对应单元格中取出值。这个例子中，单元格名字是 A1，因此 B1 被解析成 10。然而因为 B1 所依赖的目标是由 C1 计算出来的，所以不可能在构建前就知道具体的 B1 对 A1 的依赖关系。在这个特定示例中，C1 的值是固定常量，但它也可能是一长串计算链的结果，因此其实际值只有在构建过程中才能确定。

为支持动态依赖关系，EXCEL 的计算引擎与 MAKE 存在显著差异。EXCEL 将单元格排列为线性序列（称为计算链），构建时按该顺序处理单元格。但若计算单元格 C 需要尚未计算的单元格 D 的值，EXCEL 会中止 C 的计算，将 D 移至 C 之前的计算链位置，并从 D 开始重新构建。构建完成后，最终计算链将满足电子表格的所有动态依赖关系。当输入值或公式变更时，EXCEL 会以上次构建的最终计算链为起点——这样在常见场景（即输入值变更不改变依赖关系时）可避免计算中止。

动态依赖关系使得最小化重建变得复杂。在上述示例中，仅当 A1 或 C1 发生变化时 B1 才需要重新计算（例如 A2 变化时则无需计算），但这些依赖关系无法静态确定。实践中，EXCEL 采用保守近似策略来实现最小化重建：当满足以下条件时触发公式重算：
- 公式静态引用了被修改的单元格；
例如修改 C1 那 B1 就需要重新计算
- 公式使用了类似 INDIRECT 这类依赖关系无法静态分析的函数；
任何单元格的变更都会触发 B1 重新计算
- 公式本身被修改。
B1 的公式发生变化

第三条准则揭示了 EXCEL 的另一显著特性：自我追踪机制。多数构建系统仅追踪输入和中间结果的变化，而EXCEL还会追踪任务本身（即公式）的变更——当公式被修改时，EXCEL 会自动重算并传播变更。这种自我追踪在软件构建系统中较为罕见，后者通常需要手动触发完整重建（即使仅单个任务发生变化）。

为啥这种自追踪比较罕见呢，就拿 make 举例子，我们在文件没有发生变化的时候，修改 makefile 中某一个规则是不会触发重建的。因为 make 没有追踪自己内部指令的变化。

```
a.o:a.c
	clang++ -c a.c -o a.o

main.o:main.c
	clang++ -c main.c -o main.o

run: main.o a.o 
	clang++ -o run main.o a.o

我们在构建完成后，修改内容如下，重新 make run，不会触发 a.o 的构建。

a.o:a.c
	clang++ -c a.c -o a.o
    echo "Hello"

main.o:main.c
	clang++ -c main.c -o main.o

run: main.o a.o 
	clang++ -o run main.o a.o

```

### 2.3 SHAKE: 没有遗憾的动态依赖

SHAKE的研发旨在解决动态依赖关系问题，同时不牺牲最小化要求。

<img src="compile/buildsystem/paper/01/resources/2.png" style="width:50%">

```txt
    "program" %> \out -> do
        need ["o.txt"]
        objs <- lines <$> readFile' "o.txt"
        need objs
        cmd_ "gcc" "-o" out objs

    "o.txt" %> \out -> do
        srcs <- getDirectoryFiles "src" ["//*.c"]
        let objs = [dropDirectory1 s -<.> "o" | s <- srcs]
        writeFile' out (unlines objs)

    "*.o" %> \out -> do
        let src = "src" </> (out -<.> "c")
        need [src]
        deps <- cmdValue "gcc" "-MM" src
        need (words deps)
        cmd_ "gcc" "-c" src "-o" out
```

假如我们有这样的一个工程，我们的编译目标是 program，它需要的目标文件列表保存在文件 o.txt 中，执行的时候就是从 o.txt 中拿出所有的目标文件，进行链接即可，在目标文件没有的时候，需要去执行编译指令完成目标文件的生成。

当前的工作区状态如下:

```txt
./src/main.c
./src/lib.c
./lib.h
```

SHAKE 工作原理，SHAKE 包含 显式文件依赖 和 隐式动作依赖 两种依赖形式，使用 need 语法声明的就是式文件依赖，调用其他 API，例如 readFile 或者 getDirectoryFiles 就是隐式动作依赖。


1. 首次执行 `shake program`

- SHAKE 发现 program 不存在，就直接运行 program 的规则块。
- 第一个规则依赖 o.txt, 发现 o.txt 不存在，就挂起当前 program 的规则运行并去运行 o.txt 的规则块。
- o.txt 中第一个规则是从 src 目录下读取所有的 c 文件，并获取名字。随后将这些名字拼接上 .o 按照一行一个的格式写入 o.txt 文件。
- o.txt 生成完成，重新执行 programe 规则块，program 从 o.txt 中读取每一行内容，并 依赖他们。这里就是 need ["main.o", "lib.o"]
- 发现这两个 o 文件都没有，就暂停当前规则块，去执行对应的 *.o 规则块。
- 以 main.o 规则块举例
    - 里面依赖了 [src] 文件，但是 src 文件已经存在了所以没有阻塞，继续执行。
    - 这里调用了 gcc -MM 指令获取这个文件依赖的头文件信息，并依赖，在这就是 ["lib.h"],因为 lib.h 存在，所以这里不会进行阻塞。
    - 执行 gcc -c 生成对应的 main.o 文件
- 唤醒 program 块，执行 gcc 生成最终的输出信息。

首次执行完成后我们的工作区状态如下：

```txt
./src/main.c
./src/lib.c
./lib.h

main.o                          // 编译产物
lib.o                           // 编译产物
program                         // 编译产物

_build/deps_graph_data          // 编译依赖数据库


2. 重新执行

- SHAKE 发现 program 存在，但是这不够，因为有可能依赖发生变化，所以 SHAKE 查看了自己的依赖数据库，首先发现 program 依赖了 o.txt。
    - 检查 o.txt 是够需要重新构建，首先 o.txt 存在，
    - 那就进一步查看依赖数据库，发现 o.txt 有一个 隐式动作依赖 getDirectoryFiles，执行这个动作，获取输出，和数据库中记录的输出做对比，发现没有变化。
    - 判定 o.txt 没有变化。
- SHAKE 发现自己还依赖了 main.o 和 lib.o
    - 检查 main.o 是否需要重建，首先 main.o 存在。
    - 进一步查看 main.o 的依赖数据库，发现依赖了同名 c 文件以及头文件。
    - 查看数据库发现这些 c 文件和头文件没有任何变化。
    - 判定 main.o 没有变化，lib.o 同理。
- SHAKE 发现 program 所有的依赖都没有变化，判定不需要构建。


3. 修改后执行

简单的修改了源文件内容后，重新编译过程很容易理解。我们这里考虑一个特殊情况，就我在 src 目录下新增了一个 c 文件，此时，是否可以如预期一般，将这个 c 文件也参与编译和链接。

```txt
./src/main.c
./src/lib.c
./src/new.c  <---- 新增这个文件
./lib.h

main.o                         
lib.o                           
program                       

_build/deps_graph_data     
```

- SHAKE 发现 program 存在，但是这不够，因为有可能依赖发生变化，所以 SHAKE 查看了自己的依赖数据库，首先发现 program 依赖了 o.txt。
    - 检查 o.txt 是够需要重新构建，首先 o.txt 存在，
    - 那就进一步查看依赖数据库，发现 o.txt 有一个 隐式动作依赖 getDirectoryFiles，执行这个动作，获取输出，和数据库中记录的输出做对比。发现新增了一个 new.o 的内容。
    - 判定 o.txt 发生变化。
- 判定 program 需要重新构建，执行规则块，首先阻塞在 o.txt 规则块，等待 o.txt 执行完成。
    - o.txt 是过期的，所以重新执行，生成新的 o.txt (包含 new.o 项)，唤醒 program。
- program 继续执行，发现自己依赖了 ["main.o", "lib.o", "new.o"]
    - 执行 main.o 和 lib.o 发现他们是最新的，跳过。
    - 执行 new.o，发现 new.o 不存在，对依赖的 new.c 和 所需头文件做了存在判断后，执行 gcc -c 生成 new.o
- program 继续执行，生成新的 program 可执行文件。




