# 构建系统组装：理论与实践

> 本文总阅读量 <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>次

> [原文链接](https://www.cambridge.org/core/journals/journal-of-functional-programming/article/build-systems-a-la-carte-theory-and-practice/097CE52C750E69BD16B78C318754C7A4)

## Abstract

构建系统让人惊艳但是又不怎么受欢迎。它每天被世界上数以万计的开发者所使用，但是很少作为研究学习的内容。
在这个论文中，我们通过将不同的构建系统放在一起比较，得出了一个系统的且可落地的研究框架，借助于这个框架，可以更好的开发与比较不同的构建系统。
通过剖析现有的构建系统，我们可以重新组合他们的基础部件，以实现一个具有新特性的构建系统。

## 1. Introduction
例如 Make，构建系统这种软件是庞大且复杂的，每天被全球数以万计的软件开发人员所使用。但是构建系统往往是软件生态中被遗忘的部分，往往是达成目标的手段，而不会获得更多的关注在其本身。在 Make 统治了数年之后，现在新的场景和需求已经驱动了大量的软件公司，例如微软 、FaceBook 、和 Google 去开发他们自己的构建系统，并在构建系统领域探索新的方案与设计。这些复杂的构建系统使用了一些精妙/微妙的算法，但是往往将其隐藏在底层，并不需要用户进一步了解。

在这个论文中，我们给出一个用于理解和比较构建系统的通用框架，某种程度上来说，这个框架屏蔽了具体的细节，从更高维度去解释构建系统，但是同时也是可实现的。下面具体指出了，我们做的主要工作：

- 构建系统在很多方面存在差异，例如：静态依赖与动态依赖 、本地与云端 、确定性与非确定性构建系统 、早期截断(early cutoff) 、自跟踪构建 、和不同的构建信息存储类型。在第二节，我们通过选择的四个构建系统来对这些关键特性进行说明。
- 在第三节，我们提出了一些简单但是新颖的抽象概念来概括构建系统，通过这些概念，我们可以更好的评估一个构建系统正确性。
- 在第四节和第五节，我们提出了两个被深深嵌入到构建系统的关键设计选择：任务按照什么顺序执行  、任务是否需要重新构建。上面提到的两个选择是正交关系，这也给了我们对构建系统设计空间提供了新的分类标准，这将在第六节进一步说明。
- 基于两个设计的关键选择，我们通过对实际的构建系统：Make 、SHAKE 、BAZEL、BUCK、NIX、EXCEL 等进行细致描述，进一步证明了我们的抽象概念的正确性。
- 还有，我们可以通过组合不同的设计选择来构建出我们需要的构建系统。例如，我们可以组合 SHAKE 和 BAZEL 的优点去实现一个具有动态依赖和云构建模式的构建系统。第七节将对这种组合方式进行规则描述。

## 2. Background
不管是独立开发者还是大型组织，构建系统都是用来自动化执行一些重复的任务。在本小节，我们通过四个例子来探索构建系统的设计空间：Make，EXCEL，Bazel，SHAKE。我们仔细的选择这四个例子去阐明不同构建系统在不同方面的差异。我们在后续的章节也会针对于更多的构建系统进行讨论。

### 2.1 古老的 MAKE：静态依赖与文件更改时间

MAKE 在四十多年前被开发来用于源码到库以及可执行程序的构建。它使用 makefiles 文件来进行描述任务，通常被描述成构建规则和构建依赖：

```makefile
util.o: util.h util.c
    gcc -c util.c

main.o: util.h main.c
    gcc -c main.c

main.exe: util.o main.o
    gcc util.o main.o -o main.exe
```

在上面的 makefile 中列举了三个任务：(1) 通过执行 `gcc -c` 命令来将 util.c 编译生成一个工具类的库。 (2) 编译主函数的源代码文件 main.c 生成 main.o。（3）将目标文件 main.o 和 util.o 连接生成可执行文件 main.exe。从这个 makefile 文件中我们可以得到关于这个任务依赖图的完整信息，如下图(a) 所示 。

<img src="compile/buildsystem/paper/01/resources/1.png" style="width:50%">

如果用户指定 main.exe 为输出执行 make 命令，因为 main.o 和 util.o 之间相互独立，MAKE 将会以任意的顺序来执行这两个任务(甚至是并行)，然后执行 main.exe 生成所需结果。

如果用户修改了 util.h 然后重新运行，因为所有的三个任务都传递性的依赖了 util.h，MAKE 将执行一次全量重新构建 (full rebuild)，就像图 (b) 中描述的。

如果用户修改了 main.c, 那将会只执行一次部分构建: util.o 没有必要被重新构建，因为它的输入没有被更改，如图 (c) 所示。

可以观察到图中的任务不存在循环依赖，那每个任务在每次构建中最多被运行一次。一般来说，循环依赖在构建系统中是被禁止的，但是也有一些特殊情况，这点我们将在 8.5 小节进行说明。

在一次重新构建过程中，执行的任务数量越少约好。更具体的来讲，我们提出下面这个属性来描述构建系统，这个属性至关重要，也是我们为什么需要构建系统的原因：

<b>最小性(Minimality)</b>:如果一个构建系统的任务在一次构建过程中最多构建一次并且只有在它的输入自从上次构建后发生变更才会进行构建那我们称这个构建系统是最小化的。
> - 一个任务只会再一次构建中构建一次。
> - 输入没有变化则不会发生构建。

最小性这一特性与构建系统的正确性有着紧密的联系，我们会在 3.6 小节进行更详细的解释。但是现在，我们会把最小性作为我们分析构建系统的一个指导原则。

为了实现最小性，MAKE 提出了两个主要的思路：(1) MAKE 使用文件修改时间来判断文件是否更改。 (2) 按照 makefile 中的描述构建了一个静态的任务依赖图，并按照拓扑排序的方式执行任务。对于更具体的描述，我们会在 4.1 小节和 6.2 小节进行解释。
> 拓扑排序（Topological Order）是指对有向无环图（DAG）中顶点的一种线性排序，使得如果图中存在一条从顶点 \(u\) 到顶点 \(v\) 的路径，那么在拓扑排序中，顶点 \(u\) 出现在顶点 \(v\) 的前面。拓扑排序常常用于描述一系列任务或依赖关系，确保任务按照依赖关系的顺序进行。在构建系统中，拓扑排序常用于确定构建任务的执行顺序，以确保依赖关系被正确处理。


### 2.2 EXCEL: 牺牲了最小性的动态依赖
