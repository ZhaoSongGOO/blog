# 构建系统组装：理论与实践

> 本文总阅读量 <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>次

> [原文链接](https://www.cambridge.org/core/journals/journal-of-functional-programming/article/build-systems-a-la-carte-theory-and-practice/097CE52C750E69BD16B78C318754C7A4)

## Abstract

构建系统让人惊艳但是又不怎么受欢迎。它每天被世界上数以万计的开发者所使用，但是很少作为研究学习的内容。
在这个论文中，我们通过将不同的构建系统放在一起比较，得出了一个系统的且可落地的研究框架，借助于这个框架，可以更好的开发与比较不同的构建系统。
通过剖析现有的构建系统，我们可以重新组合他们的基础部件，以实现一个具有新特性的构建系统。

## 1. Introduction
例如 Make，构建系统这种软件是庞大且复杂的，每天被全球数以万计的软件开发人员所使用。但是构建系统往往是软件生态中被遗忘的部分，往往是达成目标的手段，而不会获得更多的关注在其本身。在 Make 统治了数年之后，现在新的场景和需求已经驱动了大量的软件公司，例如微软 、FaceBook 、和 Google 去开发他们自己的构建系统，并在构建系统领域探索新的方案与设计。这些复杂的构建系统使用了一些精妙/微妙的算法，但是往往将其隐藏在底层，并不需要用户进一步了解。

在这个论文中，我们给出一个用于理解和比较构建系统的通用框架，某种程度上来说，这个框架屏蔽了具体的细节，从更高维度去解释构建系统，但是同时也是可实现的。下面具体指出了，我们做的主要工作：

- 构建系统在很多方面存在差异，例如：静态依赖与动态依赖 、本地与云端 、确定性与非确定性构建系统 、早期截断(early cutoff) 、自跟踪构建 、和不同的构建信息存储类型。在第二节，我们通过选择的四个构建系统来对这些关键特性进行说明。
- 在第三节，我们提出了一些简单但是新颖的抽象概念来概括构建系统，通过这些概念，我们可以更好的评估一个构建系统正确性。
- 在第四节和第五节，我们提出了两个被深深嵌入到构建系统的关键设计选择：任务按照什么顺序执行  、任务是否需要重新构建。上面提到的两个选择是正交关系，这也给了我们对构建系统设计空间提供了新的分类标准，这将在第六节进一步说明。
- 基于两个设计的关键选择，我们通过对实际的构建系统：Make 、SHAKE 、BAZEL、BUCK、NIX、EXCEL 等进行细致描述，进一步证明了我们的抽象概念的正确性。
- 还有，我们可以通过组合不同的设计选择来构建出我们需要的构建系统。例如，我们可以组合 SHAKE 和 BAZEL 的优点去实现一个具有动态依赖和云构建模式的构建系统。第七节将对这种组合方式进行规则描述。

## 2. Background
不管是独立开发者还是大型组织，构建系统都是用来自动化执行一些重复的任务。在本小节，我们通过四个例子来探索构建系统的设计空间：Make，EXCEL，Bazel，SHAKE。我们仔细的选择这四个例子去阐明不同构建系统在不同方面的差异。我们在后续的章节也会针对于更多的构建系统进行讨论。

### 2.1 古老的 MAKE：静态依赖与文件更改时间

MAKE 在四十多年前被开发来用于源码到库以及可执行程序的构建。它使用 makefiles 文件来进行描述任务，通常被描述成构建规则和构建依赖：

```makefile
util.o: util.h util.c
    gcc -c util.c

main.o: util.h main.c
    gcc -c main.c

main.exe: util.o main.o
    gcc util.o main.o -o main.exe
```

在上面的 makefile 中列举了三个任务：(1) 通过执行 `gcc -c` 命令来将 util.c 编译生成一个工具类的库。 (2) 编译主函数的源代码文件 main.c 生成 main.o。（3）将目标文件 main.o 和 util.o 连接生成可执行文件 main.exe。从这个 makefile 文件中我们可以得到关于这个任务依赖图的完整信息，如下图(a) 所示 。

<img src="compile/buildsystem/paper/01/resources/1.png" style="width:50%">

如果用户指定 main.exe 为输出执行 make 命令，因为 main.o 和 util.o 之间相互独立，MAKE 将会以任意的顺序来执行这两个任务(甚至是并行)，然后执行 main.exe 生成所需结果。

如果用户修改了 util.h 然后重新运行，因为所有的三个任务都传递性的依赖了 util.h，MAKE 将执行一次全量重新构建 (full rebuild)，就像图 (b) 中描述的。

如果用户修改了 main.c, 那将会只执行一次部分构建: util.o 没有必要被重新构建，因为它的输入没有被更改，如图 (c) 所示。

可以观察到图中的任务不存在循环依赖，那每个任务在每次构建中最多被运行一次。一般来说，循环依赖在构建系统中是被禁止的，但是也有一些特殊情况，这点我们将在 8.5 小节进行说明。

在一次重新构建过程中，执行的任务数量越少约好。更具体的来讲，我们提出下面这个属性来描述构建系统，这个属性至关重要，也是我们为什么需要构建系统的原因：

<b>最小性(Minimality)</b>:如果一个构建系统的任务在一次构建过程中最多构建一次并且只有在它的输入自从上次构建后发生变更才会进行构建那我们称这个构建系统是最小化的。
> - 一个任务只会再一次构建中构建一次。
> - 输入没有变化则不会发生构建。

最小性这一特性与构建系统的正确性有着紧密的联系，我们会在 3.6 小节进行更详细的解释。但是现在，我们会把最小性作为我们分析构建系统的一个指导原则。

为了实现最小性，MAKE 提出了两个主要的思路：(1) MAKE 使用文件修改时间来判断文件是否更改。 (2) 按照 makefile 中的描述构建了一个静态的任务依赖图，并按照拓扑排序的方式执行任务。对于更具体的描述，我们会在 4.1 小节和 6.2 小节进行解释。
> 拓扑排序（Topological Order）是指对有向无环图（DAG）中顶点的一种线性排序，使得如果图中存在一条从顶点 \(u\) 到顶点 \(v\) 的路径，那么在拓扑排序中，顶点 \(u\) 出现在顶点 \(v\) 的前面。拓扑排序常常用于描述一系列任务或依赖关系，确保任务按照依赖关系的顺序进行。在构建系统中，拓扑排序常用于确定构建任务的执行顺序，以确保依赖关系被正确处理。


### 2.2 EXCEL: 牺牲了最小性的动态依赖


```txt
    "program" %> \out -> do
        need ["o.txt"]
        objs <- lines <$> readFile' "o.txt"
        need objs
        cmd_ "gcc" "-o" out objs

    "o.txt" %> \out -> do
        srcs <- getDirectoryFiles "src" ["//*.c"]
        let objs = [dropDirectory1 s -<.> "o" | s <- srcs]
        writeFile' out (unlines objs)

    "*.o" %> \out -> do
        let src = "src" </> (out -<.> "c")
        need [src]
        deps <- cmdValue "gcc" "-MM" src
        need (words deps)
        cmd_ "gcc" "-c" src "-o" out
```

假如我们有这样的一个工程，我们的编译目标是 program，它需要的目标文件列表保存在文件 o.txt 中，执行的时候就是从 o.txt 中拿出所有的目标文件，进行链接即可，在目标文件没有的时候，需要去执行编译指令完成目标文件的生成。

当前的工作区状态如下:

```txt
./src/main.c
./src/lib.c
./lib.h
```

SHAKE 工作原理，SHAKE 包含 显式文件依赖 和 隐式动作依赖 两种依赖形式，使用 need 语法声明的就是式文件依赖，调用其他 API，例如 readFile 或者 getDirectoryFiles 就是隐式动作依赖。

1. 首次执行 `shake program`

- SHAKE 发现 program 不存在，就直接运行 program 的规则块。
- 第一个规则依赖 o.txt, 发现 o.txt 不存在，就挂起当前 program 的规则运行并去运行 o.txt 的规则块。
- o.txt 中第一个规则是从 src 目录下读取所有的 c 文件，并获取名字。随后将这些名字拼接上 .o 按照一行一个的格式写入 o.txt 文件。
- o.txt 生成完成，重新执行 programe 规则块，program 从 o.txt 中读取每一行内容，并 依赖他们。这里就是 need ["main.o", "lib.o"]
- 发现这两个 o 文件都没有，就暂停当前规则块，去执行对应的 *.o 规则块。
- 以 main.o 规则块举例
    - 里面依赖了 [src] 文件，但是 src 文件已经存在了所以没有阻塞，继续执行。
    - 这里调用了 gcc -MM 指令获取这个文件依赖的头文件信息，并依赖，在这就是 ["lib.h"],因为 lib.h 存在，所以这里不会进行阻塞。
    - 执行 gcc -c 生成对应的 main.o 文件
- 唤醒 program 块，执行 gcc 生成最终的输出信息。

首次执行完成后我们的工作区状态如下：

```txt
./src/main.c
./src/lib.c
./lib.h

main.o                          // 编译产物
lib.o                           // 编译产物
program                         // 编译产物

_build/deps_graph_data          // 编译依赖数据库
```


2. 重新执行

- SHAKE 发现 program 存在，但是这不够，因为有可能依赖发生变化，所以 SHAKE 查看了自己的依赖数据库，首先发现 program 依赖了 o.txt。
    - 检查 o.txt 是够需要重新构建，首先 o.txt 存在，
    - 那就进一步查看依赖数据库，发现 o.txt 有一个 隐式动作依赖 getDirectoryFiles，执行这个动作，获取输出，和数据库中记录的输出做对比，发现没有变化。
    - 判定 o.txt 没有变化。
- SHAKE 发现自己还依赖了 main.o 和 lib.o
    - 检查 main.o 是否需要重建，首先 main.o 存在。
    - 进一步查看 main.o 的依赖数据库，发现依赖了同名 c 文件以及头文件。
    - 查看数据库发现这些 c 文件和头文件没有任何变化。
    - 判定 main.o 没有变化，lib.o 同理。
- SHAKE 发现 program 所有的依赖都没有变化，判定不需要构建。

3. 修改后执行

简单的修改了源文件内容后，重新编译过程很容易理解。我们这里考虑一个特殊情况，就我在 src 目录下新增了一个 c 文件，此时，是否可以如预期一般，将这个 c 文件也参与编译和链接。

```txt
./src/main.c
./src/lib.c
./src/new.c  <---- 新增这个文件
./lib.h

main.o                         
lib.o                           
program                       

_build/deps_graph_data     
```

- SHAKE 发现 program 存在，但是这不够，因为有可能依赖发生变化，所以 SHAKE 查看了自己的依赖数据库，首先发现 program 依赖了 o.txt。
    - 检查 o.txt 是够需要重新构建，首先 o.txt 存在，
    - 那就进一步查看依赖数据库，发现 o.txt 有一个 隐式动作依赖 getDirectoryFiles，执行这个动作，获取输出，和数据库中记录的输出做对比。发现新增了一个 new.o 的内容。
    - 判定 o.txt 发生变化。
- 判定 program 需要重新构建，执行规则块，首先阻塞在 o.txt 规则块，等待 o.txt 执行完成。
    - o.txt 是过期的，所以重新执行，生成新的 o.txt (包含 new.o 项)，唤醒 program。
- program 继续执行，发现自己依赖了 ["main.o", "lib.o", "new.o"]
    - 执行 main.o 和 lib.o 发现他们是最新的，跳过。
    - 执行 new.o，发现 new.o 不存在，对依赖的 new.c 和 所需头文件做了存在判断后，执行 gcc -c 生成 new.o
- program 继续执行，生成新的 program 可执行文件。



