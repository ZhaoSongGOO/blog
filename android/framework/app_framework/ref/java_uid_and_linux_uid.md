```
那分配 uid 是如何应对到 linux 的用户 id 呢？
```

---

太棒了，你又问到了一个直击底层的关键问题！`android:sharedUserId` 和 Linux UID 之间的“映射”或“转换”关系，正是 Android 安全模型得以实现的核心机制之一。

答案是：**没有复杂的“映射”，它们本质上就是同一个东西！** Android 框架层分配的 UID，被**直接用作** Linux 内核层的 UID。

这个“直接使用”的过程，是通过一个精心设计的、涉及多个系统服务的协作流程来完成的。我们把它拆解成两个主要部分：**进程身份的设定** 和 **文件系统所有权的设定**。

---

### 1. 进程身份的设定：Zygote 和 `setuid` 的魔术

这是最关键的一步，发生在你的 App 进程启动的瞬间。

#### 背景：Zygote - Android 的“进程孵化器”

*   在 Android 系统启动时，会有一个名为 **Zygote** 的特殊进程被创建。
*   Zygote 是所有 App 进程的“父进程”。它是一个预加载了 Android 核心类库的 Java 虚拟机。
*   最重要的是，Zygote 进程是以 **`root` 用户 (UID=0)** 的身份运行的。这是它能施展“魔术”的前提。

#### 启动 App 进程的流程：

1.  **请求启动**：当你要启动一个 App 时（比如点击桌面图标），`ActivityManagerService` (AMS) 会收到这个请求。

2.  **查询 UID**：AMS 会向 `PackageManagerService` (PMS) 查询：“我要启动 `com.example.app`，请告诉我它的 UID 是多少？” PMS 会从内存中（也就是从 `packages.xml` 加载来的信息）查到这个 App 的 UID，比如是 `10190`，然后告诉 AMS。

3.  **命令 Zygote**：AMS 向 Zygote 进程发送一个 socket 消息，命令它：“请为我孵化（fork）一个新的子进程，并为这个子进程设置 UID 为 `10190`。”

4.  **Zygote 的核心操作**：
    *   **`fork()`**：Zygote 调用 Linux 的 `fork()` 系统调用，创建一个和自己几乎一模一样的子进程。这个子进程在刚被创建的瞬间，也继承了 Zygote 的 `root` 身份。
    *   **`setuid()`**：这是**最关键的一步**。在加载任何 App 自己的代码之前，这个新的子进程会立即调用 Linux 的 `setuid()` 和 `setgid()` 系统调用，将自己的用户 ID 和组 ID 从 `root` (0) **降级**为 AMS 指定的那个 UID (`10190`)。
        *   **为什么必须由 Zygote (root) 来做？** 因为在 Linux 中，只有 `root` 进程有权限将自己的身份变成**任何其他用户**。一个普通用户进程是无法将自己变成另一个普通用户的。
    *   **加载代码**：在成功降级为普通 App 的 UID (`10190`) 之后，这个进程才开始加载属于 `com.example.app` 的代码（APK 文件），并执行它的入口点。

**结果**：从这一刻起，这个新创建的进程在 Linux 内核看来，就是一个普普通通的、UID 为 `10190` 的进程。它已经永远失去了 `root` 权限。内核会严格按照 UID `10190` 的权限来限制它的一切行为。

---

### 2. 文件系统所有权的设定：`installd` 和 `chown`

光有进程身份还不够，还需要有对应的数据地盘。

这个过程发生在 App **安装**时，而不是每次启动时。

1.  **分配 UID**：当 App 首次安装时，PMS 决定了它的 UID（比如 `10190`）。

2.  **创建目录**：PMS 会通过 `installd` 这个守护进程（一个以 `root` 权限运行的本地服务）来执行文件系统操作。

3.  **`chown`**：`installd` 会为 App 创建它的私有数据目录，例如 `/data/data/com.example.app`。然后，它会立即调用 Linux 的 `chown` (change owner) 命令/系统调用，将这个目录以及其下所有文件和子目录的**所有者**和**所有组**都设置为刚刚分配的那个 UID (`10190`)。

**结果**：App 的数据目录在文件系统层面被“盖上了戳”，明确标明它只属于 UID `10190`。

---

### 总结：天衣无缝的配合

你看，这是一个完美的闭环：

| 阶段 | 负责者 | 动作 | 结果 |
| :--- | :--- | :--- | :--- |
| **安装时** | PMS + `installd` | 1. 决定 App 的 UID (例如 `10190`)<br>2. 创建数据目录<br>3. `chown` 目录所有者为 `10190` | App 有了一块**只属于 UID `10190` 的地盘**。 |
| **运行时** | AMS + Zygote | 1. `fork()` 新进程<br>2. `setuid()` 将进程身份设置为 `10190` | App 的进程以 **UID `10190` 的身份**在运行。 |

当这个 UID 为 `10190` 的进程，去尝试访问那个所有者为 `10190` 的目录时，Linux 内核检查后发现“身份匹配”，于是允许访问。

当它去尝试访问另一个 App 的目录（比如所有者是 `10191`）时，内核检查后发现“身份不匹配”，于是拒绝访问，抛出 `Permission Denied` 错误。

所以，**Android 的 UID 就是 Linux 的 UID**。Android 框架层（PMS, AMS）负责**管理和分配**这些 UID，而底层的 Zygote 和 `installd` 则负责在**创建进程和文件时，将这些 UID 应用到 Linux 内核层面**，从而将 Android 的沙箱设计真正落地实现。

---

```
那我可以这样理解吗？ PMS 解析出来的 app uid 都是在创建进程时，给这个进程设置 uid的，至于资源文件等东西在首次安装时就已经设置好 id了是吧
```

---

对！你的这个理解**完全正确**，而且非常精准地抓住了两个关键的时间点：**“安装时”** 和 **“运行时”**。

这正是 Android 系统权限和沙箱模型的核心运作方式。我们来把你这个完美的总结再强化一下：

---

### 1. 安装时（一次性设置）

这个阶段是为 App **“划分地盘”** 和 **“盖上地契”**。

*   **执行者**：`PackageManagerService` (PMS) 负责决策，`installd` 守护进程负责具体施工。
*   **核心动作**：
    1.  **分配 UID**：PMS 为新安装的 App（或 `sharedUserId` 群组）确定一个唯一的 UID。这个 UID 从此就和这个 App 绑定了。
    2.  **创建数据目录**：`installd` 在 `/data/data/` 下创建 App 的私有目录（例如 `com.example.app`）。
    3.  **设置所有权 (`chown`)**：`installd` 将这个目录及其未来所有内容的所有者（Owner）和所有组（Group）都设置为刚刚分配的那个 UID。
*   **结果**：App 的私有资源文件（数据库、SharedPreferences、缓存等）在文件系统层面被牢牢地打上了“身份烙印”。这个“地契”已经写好，规定了只有这个 UID 的“主人”才能访问。**这个操作是一次性的，在 App 的整个生命周期中（除非被卸载重装），这个目录的所有权不会再改变。**

---

### 2. 运行时（每次启动都发生）

这个阶段是为 App 进程 **“授予身份”**，让它能够去访问自己的“地盘”。

*   **执行者**：`ActivityManagerService` (AMS) 负责调度，`Zygote` 进程负责具体孵化。
*   **核心动作**：
    1.  **查询 UID**：AMS 向 PMS 查询要启动的 App 的 UID。
    2.  **孵化进程 (`fork`)**：`Zygote` (以 root 身份运行) 创建一个子进程。
    3.  **设定身份 (`setuid`)**：子进程立即放弃 root 权限，将自己的进程 UID 设置为从 AMS 获取到的那个 App 的 UID。
*   **结果**：App 的进程现在以正确的“主人”身份在运行。当它去访问文件系统时，Linux 内核会检查它的进程 UID 和它想访问的文件的所有者 UID。因为两者完全匹配，所以访问被允许。**这个“授予身份”的过程，在每次 App 启动一个新进程时都会发生。**

---

### 总结与类比

你的理解可以完美地用一个银行保险箱的例子来类比：

*   **安装时（办理业务）**：
    *   你去银行（**PMS**）申请一个保险箱（**App**）。
    *   银行给你分配了一个独一无二的钥匙编号（**UID**）。
    *   银行职员（**`installd`**）带你到一个保险箱（**数据目录**），并把这个箱子的锁芯设置成只有你的那把钥匙（**UID**）才能打开。这个设置是一次性的。

*   **运行时（存取物品）**：
    *   每次你想去存取东西时，你都要先到前台（**AMS**）。
    *   保安队长（**Zygote**）会验证你的身份，然后给你一把当次使用的、对应你钥匙编号的钥匙（**`setuid` 授予进程身份**）。
    *   你拿着这把钥匙（**进程 UID**）走到你的保险箱（**数据目录**）前，插进去，锁芯（**Linux 内核**）验证钥匙编号匹配，咔嚓，门开了。
    *   你想去开别人的保险箱？对不起，钥匙编号不匹配，打不开。

所以，你说的没错：

> **PMS 解析出来的 app uid 都是在创建进程时，给这个进程设置 uid 的，至于资源文件等东西在首次安装时就已经设置好 id 了。**

这个总结非常到位，清晰地区分了静态的“所有权设置”和动态的“身份授予”，这两者共同构成了 Android 应用沙箱的基石。