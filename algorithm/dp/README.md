# 动态规划


## [最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/description/)

给你一个字符串 s，找到 s 中最长的 回文 子串。

想要找到最长的回文子串，我们必须要做的就是找到所有的回文子串，从这里面找出最长的，没有捷径。

先考虑暴力解法，我们可以枚举所有的子串，判断其是不是回文的，是的话，记录一个最大的长度串，时间复杂度是 O(n^3)。

所以我们想的是不是可以简化回文串的判断过程，

对于单个字符，其本身就是回文串。

对于紧挨的两个相等字符，例如 aa, 也是回文串。

对于一个 axxxxxa 的字符串，它是不是回文串取决于 xxxxx 是不是回文串。ok，这就是动态规划了，没得跑了。

所以我们得到公式 dp[i][j] 代表子串 [i, j] 是不是回文串。

if i == j  => dp[i][j] = true
else
    if abs(i -j) == 1 => dp[i][j] = s[i] == s[j]
    else
        dp[i][j] = s[i] == s[j] && dp[i+1][j-1]




