## 一个基础的 jni 应用流程
### 编写 java 文件

```java
// Hello.java

public class Hello{
    static {
        // 加载 c 库
        System.loadlibrary("hello");
    }

    // native 关键字 表明这是一个 native 方法
    public native String nativeString();

    public static void main(String []args){
        String value = new Hello().nativeString();
        System.out.ptintln(value);
    }
}
```

### 编写 c 文件并生成 c 库
编写自己的 c 文件，这里有个问题是，我们 c 方法的签名是什么?
1. 获取 c 方法的签名

执行 javac 命令，导出 jni 头文件。
```bash
javac -h . Hello.java
cat Hello.h
```
jni 头文件内容如下：
```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class Hello */

#ifndef _Included_Hello
#define _Included_Hello
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     Hello
 * Method:    nativeString
 * Signature: ()Ljava/lang/String;
 */

// 这里就是我们 c 方法的函数签名
JNIEXPORT jstring JNICALL Java_Hello_nativeString
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
```

2. 实现自己的 c 方法

```c
// Hello.c

#include <stdio.h>
#include <jni.h>


// 函数实现，返回字符串 Hello from JNI!
// JNIEnv: 提供了一些 jni 调用中会使用到的函数。存储了一些调用的上下文对象。
// jobject: this 指针，在本例中代表 Hello 对象，如果 jni 方法在 java 中是 static 的，那传入的就是 jclass，即 Hello 类型。
JNIEXPORT jstring JNICALL Java_Hello_sayHello
  (JNIEnv * env , jobject obj){
    return (*env)->NewStringUTF(env,"Hello from JNI !");
}

```

3. 编译生成 c 库

```bash
# 因为我是 mac 系统，这里头文件路径里面是 darwin，你要是 linux，就将 darwin 改成 linux即可
# JAVA_HOME 的值类似于 /Library/Java/JavaVirtualMachines/adoptopenjdk-11.jdk/Contents/Home，指向你自己 JDK 的路径。
# 这里需要注意，在darwin 系统上，我们生成的动态库后缀应该是 dylib, jdk 的 loadLibrary 方法会进行后缀判断，如果后缀不对，则拒绝加载
# 在 linux 上，则是以 so 作为后缀
clang -fpic -I"$JAVA_HOME/include" -I"$JAVA_HOME/include/darwin" -shared -o libhello.dylib Hello.c

```

### 执行 java 文件

```bash
# -Djava.library.path 声明我们的 c 库所在路径
java Hello -Djava.library.path=.
```
![执行输出](resources/jni_1.png)

## jni 动态注册
上面的 demo 展示的是 jni 提供的静态注册示例，其实 jni 还提供了动态注册机制。允许我们更灵活的将 jni 方法与 c 方法进行绑定，稍后你会看到动态注册带来的灵活性。

### 重新编写 Hello.c 文件

```c
#include <stdio.h>
#include <jni.h>

// 我不需要按照要求设置函数名称，而是可以写成自己需要的形式
JNIEXPORT jstring JNICALL NativeStringFunction
  (JNIEnv * env , jobject obj){
    return (*env)->NewStringUTF(env,"Hello from JNI dynamic regist!");
  }

/*  灵活映射：jnifunction -> nativefunction
    nativeString: java 层函数名称
    ()Ljava/lang/String; : java 层函数签名 （注意需要加 ';'）
    NativeStringFunction: c 函数指针
*/
static JNINativeMethod methods[] = {
  {
    "nativeString", "()Ljava/lang/String;", (void*)NativeStringFunction
  }
};

JNIEXPORT jint JNICALL
JNI_OnLoad(JavaVM *vm, void *reserved) {
    JNIEnv *env = NULL;
    jint result = -1;
 
    if ((*vm)->GetEnv(vm, (void**) &env, JNI_VERSION_1_6) != JNI_OK) {
        return result;
    }
    
    // 找到 java 的类
    const char* className = "Hello";
    jclass clazz = (*env)->FindClass(env, className);
    if (clazz == NULL) {
        return result;
    }
    
    // 注册 native 方法
    if ((*env)->RegisterNatives(env, clazz, methods, sizeof(methods) / sizeof(methods[0])) < 0) {
        return result;
    }
 
    result = JNI_VERSION_1_6;
    return result;
}

```

![执行输出](resources/jni_2.png)




